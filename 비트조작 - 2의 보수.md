# 비트조작 - 2의 보수
### *2의 보수 숫자 포맷*


```python
# 자릿수 제한 비트 연산
MASK = 0xF
bin(1 & MASK)
```




    '0b1'




```python
bin(7 & MASK)
```




    '0b111'




```python
bin(-8 & MASK)
```




    '0b1000'




```python
bin(-7 & MASK)
```




    '0b1001'




```python
bin(7)
```




    '0b111'




```python
# 파이썬 내부적으로는 2의 보수를 보여주지 않음
bin(-8)
```




    '-0b1000'




```python
bin(8)
```




    '0b1000'




```python
# AND 연산
5 & -4
```




    4




```python
# 4비트 2의 보수
bin(0b0101 & 0b1100)
```




    '0b100'




```python
# 32비트 2의 보수
bin(0b00000000000000000000000000000101 & 0b11111111111111111111111111111100)
```




    '0b100'




```python
int(0b100)
```




    4




```python
# OR 연산
5 | -4
```




    -3




```python
bin(0b0101 | 0b1100)
```




    '0b1101'




```python
bin(0b00000000000000000000000000000101 | 0b11111111111111111111111111111100)
```




    '0b11111111111111111111111111111101'



### *2의 보수 수학 연산 - 부호를 바꿔줌* 
#### 1. 비트연산자 NOT (2의 보수에서 1을 뺌)
#### 2. 1을 더해 2의 보수 수학 연산을 만든다.

### *비트 연산자 NOT*
#### - 0을 1로, 1을 0으로 바꿔줌


```python
bin(0b0101 ^ ~ 0b1100) # 입력값이 4비트 포맷이 아님
```




    '-0b1010'




```python
# 8비트 포맷으로 변경
bin(0b00000101 ^ ~0b00001100)
```




    '-0b1010'




```python
bin(0b00000101 ^ 0b11110011)
```




    '0b11110110'




```python
# 16비트일 때도 동일함
bin(0b0000000000000101 ^ ~0b0000000000001100)
```




    '-0b1010'




```python

```
